\section{Visibility \& Shadows}

\greenbf{Visibility:} Some parts of of some surfaces are occluded by other surfaces.

\greenbf{Painter's Algorithm:} Render objects/Polygons from furthest to nearest. Problem: cyclic overlaps and intersections.

\greenbf{Z-Buffering:} Store depth to the nearest object for each pixel. 1.Initially all $\infty$. 2. For each Polygon, if the z value of a pixel for this polygon is smaller than the stored z value, replace the stored z value. Problems: limited resolution (only finite number of z values), non-linear (higher resolution for near objects, lower for far objects), setting near plane far from camera exacerbates resolution problem.

\greenbf{Shadows:} Important for perception of depth, realism, indicating light position and type (point light or area light).\\
\includegraphics*[width = \columnwidth]{alex/shadowTechniqueProperties.png}\\
\greenbf{Planar Shadows:} Draw projection of object on ground.

\greenbf{Projective texture shadows:} Separate obstacle (shadow caster) and receiver. Compute b/w image of the obstacle. Use image as projective texture map.

\greenbf{Shadow Maps:} Compute the depths from the light source and from the camera. Shadow map stores depths for light source. For each pixel on the camera plane compute the point $x$ in world coordinates consider its distance $z_L$ to the light source and $d(x_L)$ which is the depth in the direction: light source-x. If $d(x_L) < z_L$, x is in shadow. In order to prevent self-shadowing add bias: $d(x_L) < z_L + bias$, too small bias causes self shadows and to large bias removes too much shadow. In order to include points which are outside the FOV for the shadow map one can use cubical shadow maps. To prevent undersampling/aliasing take weighted average of "$d(x_L) + bias < z_L$" tests instead of filtering depth directly. Bigger filters give fake soft shadows, bias tricky


\greenbf{Shadow Volumes:} Explicitly represents the volume of space in shadow. If polygon is inside the volume, it is in shadow. Similar to clipping. Naive implementation: O(\#polygons * \#lights)\\
\textbf{Algorithm:}: 
\begin{compactitem}
    \item Shoot ray from eye.
    \item Incre-/decrement counter every time boundary of a shadow volume is intersected.
    \item If counter = 0 not in shadow.
\end{compactitem}
\textbf{Optimisation:} use silhouette edges only (where back-facing and front-facing polygon meet).\\
\textbf{Limitations:} introduces a lot of new geometry, expensive to rasterize long skinny triangles, objects must be watertight for silhouette optimisation, rasterization of polygons sharing and edge must not overlap or have gap.

